{"version":3,"file":"haws.es.js","sources":["../lib/errors.ts","../lib/socket.ts","../lib/connection.ts","../lib/messages.ts","../lib/auth.ts","../lib/util.ts","../lib/store.ts","../lib/collection.ts","../lib/commands.ts","../lib/config.ts","../lib/services.ts","../lib/entities.ts","../lib/index.ts"],"sourcesContent":["export const ERR_CANNOT_CONNECT = 1;\nexport const ERR_INVALID_AUTH = 2;\nexport const ERR_CONNECTION_LOST = 3;\nexport const ERR_HASS_HOST_REQUIRED = 4;\n","/**\n * Create a web socket connection with a Home Assistant instance.\n */\nimport {\n  ERR_INVALID_AUTH,\n  ERR_CANNOT_CONNECT,\n  ERR_HASS_HOST_REQUIRED\n} from \"./errors\";\nimport { ConnectionOptions, Error } from \"./types\";\nimport * as messages from \"./messages\";\n\nconst DEBUG = false;\n\nconst MSG_TYPE_AUTH_REQUIRED = \"auth_required\";\nconst MSG_TYPE_AUTH_INVALID = \"auth_invalid\";\nconst MSG_TYPE_AUTH_OK = \"auth_ok\";\n\nexport function createSocket(options: ConnectionOptions): Promise<WebSocket> {\n  if (!options.auth) {\n    throw ERR_HASS_HOST_REQUIRED;\n  }\n  const auth = options.auth;\n\n  // Convert from http:// -> ws://, https:// -> wss://\n  const url = auth.wsUrl;\n\n  if (DEBUG) {\n    console.log(\"[Auth phase] Initializing\", url);\n  }\n\n  function connect(\n    triesLeft: number,\n    promResolve: (socket: WebSocket) => void,\n    promReject: (err: Error) => void\n  ) {\n    if (DEBUG) {\n      console.log(\"[Auth Phase] New connection\", url);\n    }\n\n    const socket = new WebSocket(url);\n\n    // If invalid auth, we will not try to reconnect.\n    let invalidAuth = false;\n\n    const closeMessage = () => {\n      // If we are in error handler make sure close handler doesn't also fire.\n      socket.removeEventListener(\"close\", closeMessage);\n      if (invalidAuth) {\n        promReject(ERR_INVALID_AUTH);\n        return;\n      }\n\n      // Reject if we no longer have to retry\n      if (triesLeft === 0) {\n        // We never were connected and will not retry\n        promReject(ERR_CANNOT_CONNECT);\n        return;\n      }\n\n      const newTries = triesLeft === -1 ? -1 : triesLeft - 1;\n      // Try again in a second\n      setTimeout(\n        () =>\n          connect(\n            newTries,\n            promResolve,\n            promReject\n          ),\n        1000\n      );\n    };\n\n    // Auth is mandatory, so we can send the auth message right away.\n    const handleOpen = async (event: MessageEventInit) => {\n      try {\n        if (auth.expired) await auth.refreshAccessToken();\n        socket.send(JSON.stringify(messages.auth(auth.accessToken)));\n      } catch (err) {\n        // Refresh token failed\n        invalidAuth = err === ERR_INVALID_AUTH;\n        socket.close();\n      }\n    };\n\n    const handleMessage = async (event: MessageEvent) => {\n      const message = JSON.parse(event.data);\n\n      if (DEBUG) {\n        console.log(\"[Auth phase] Received\", message);\n      }\n      switch (message.type) {\n        case MSG_TYPE_AUTH_INVALID:\n          invalidAuth = true;\n          socket.close();\n          break;\n\n        case MSG_TYPE_AUTH_OK:\n          socket.removeEventListener(\"open\", handleOpen);\n          socket.removeEventListener(\"message\", handleMessage);\n          socket.removeEventListener(\"close\", closeMessage);\n          socket.removeEventListener(\"error\", closeMessage);\n          promResolve(socket);\n          break;\n\n        default:\n          if (DEBUG) {\n            // We already send this message when socket opens\n            if (message.type !== MSG_TYPE_AUTH_REQUIRED) {\n              console.warn(\"[Auth phase] Unhandled message\", message);\n            }\n          }\n      }\n    };\n\n    socket.addEventListener(\"open\", handleOpen);\n    socket.addEventListener(\"message\", handleMessage);\n    socket.addEventListener(\"close\", closeMessage);\n    socket.addEventListener(\"error\", closeMessage);\n  }\n\n  return new Promise((resolve, reject) =>\n    connect(\n      options.setupRetry,\n      resolve,\n      reject\n    )\n  );\n}\n","/**\n * Connection that wraps a socket and provides an interface to interact with\n * the Home Assistant websocket API.\n */\nimport * as messages from \"./messages\";\nimport { ERR_INVALID_AUTH, ERR_CONNECTION_LOST } from \"./errors\";\nimport { ConnectionOptions, HassEvent, MessageBase } from \"./types\";\n\nconst DEBUG = false;\n\nexport type ConnectionEventListener = (\n  conn: Connection,\n  eventData?: any\n) => void;\n\ntype Events = \"ready\" | \"disconnected\" | \"reconnect-error\";\n\ntype WebSocketPongResponse = {\n  id: number;\n  type: \"pong\";\n};\n\ntype WebSocketEventResponse = {\n  id: number;\n  type: \"event\";\n  event: HassEvent;\n};\n\ntype WebSocketResultResponse = {\n  id: number;\n  type: \"result\";\n  success: true;\n  result: any;\n};\n\ntype WebSocketResultErrorResponse = {\n  id: number;\n  type: \"result\";\n  success: false;\n  error: {\n    code: string;\n    message: string;\n  };\n};\n\ntype WebSocketResponse =\n  | WebSocketPongResponse\n  | WebSocketEventResponse\n  | WebSocketResultResponse\n  | WebSocketResultErrorResponse;\n\ntype SubscribeEventCommmandInFlight = {\n  resolve: (result?: any) => void;\n  reject: (err: any) => void;\n  eventCallback: (ev: any) => void;\n  eventType?: string;\n  unsubscribe: () => Promise<void>;\n};\n\ntype CommandWithAnswerInFlight = {\n  resolve: (result?: any) => void;\n  reject: (err: any) => void;\n};\n\ntype CommandInFlight =\n  | SubscribeEventCommmandInFlight\n  | CommandWithAnswerInFlight;\n\nexport class Connection {\n  options: ConnectionOptions;\n  commandId: number;\n  commands: {\n    [commandId: number]: CommandInFlight;\n  };\n  eventListeners: {\n    [eventType: string]: ConnectionEventListener[];\n  };\n  closeRequested: boolean;\n  // @ts-ignore: incorrectly claiming it's not set in constructor.\n  socket: WebSocket;\n\n  constructor(socket: WebSocket, options: ConnectionOptions) {\n    // connection options\n    //  - setupRetry: amount of ms to retry when unable to connect on initial setup\n    //  - createSocket: create a new Socket connection\n    this.options = options;\n    // id if next command to send\n    this.commandId = 1;\n    // info about active subscriptions and commands in flight\n    this.commands = {};\n    // map of event listeners\n    this.eventListeners = {};\n    // true if a close is requested by the user\n    this.closeRequested = false;\n\n    this.setSocket(socket);\n  }\n\n  setSocket(socket: WebSocket) {\n    const oldSocket = this.socket;\n    this.socket = socket;\n    socket.addEventListener(\"message\", ev => this._handleMessage(ev));\n    socket.addEventListener(\"close\", ev => this._handleClose(ev));\n\n    if (oldSocket) {\n      const oldCommands = this.commands;\n\n      // reset to original state\n      this.commandId = 1;\n      this.commands = {};\n\n      Object.keys(oldCommands).forEach(id => {\n        const info: CommandInFlight = oldCommands[id];\n\n        if (\"eventCallback\" in info) {\n          this.subscribeEvents(info.eventCallback, info.eventType).then(\n            unsub => {\n              info.unsubscribe = unsub;\n              // We need to resolve this in case it wasn't resolved yet.\n              // This allows us to call subscribeEvents while we're disconnected\n              // and recover properly.\n              info.resolve();\n            }\n          );\n        }\n      });\n\n      this.fireEvent(\"ready\");\n    }\n  }\n\n  addEventListener(eventType: Events, callback: ConnectionEventListener) {\n    let listeners = this.eventListeners[eventType];\n\n    if (!listeners) {\n      listeners = this.eventListeners[eventType] = [];\n    }\n\n    listeners.push(callback);\n  }\n\n  removeEventListener(eventType: Events, callback: ConnectionEventListener) {\n    const listeners = this.eventListeners[eventType];\n\n    if (!listeners) {\n      return;\n    }\n\n    const index = listeners.indexOf(callback);\n\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n  }\n\n  fireEvent(eventType: Events, eventData?: any) {\n    (this.eventListeners[eventType] || []).forEach(callback =>\n      callback(this, eventData)\n    );\n  }\n\n  close() {\n    this.closeRequested = true;\n    this.socket.close();\n  }\n\n  // eventCallback will be called when a new event fires\n  // Returned promise resolves to an unsubscribe function.\n  async subscribeEvents<EventType>(\n    eventCallback: (ev: EventType) => void,\n    eventType?: string\n  ) {\n    // Command ID that will be used\n    const commandId = this._genCmdId();\n    let info: SubscribeEventCommmandInFlight;\n\n    await new Promise((resolve, reject) => {\n      // We store unsubscribe on info object. That way we can overwrite it in case\n      // we get disconnected and we have to subscribe again.\n      info = this.commands[commandId] = {\n        resolve,\n        reject,\n        eventCallback: eventCallback as (ev: any) => void,\n        eventType,\n        unsubscribe: async () => {\n          await this.sendMessagePromise(messages.unsubscribeEvents(commandId));\n          delete this.commands[commandId];\n        }\n      };\n\n      try {\n        this.sendMessage(messages.subscribeEvents(eventType), commandId);\n      } catch (err) {\n        // Happens when the websocket is already closing.\n        // Don't have to handle the error, reconnect logic will pick it up.\n      }\n    });\n\n    return () => info.unsubscribe();\n  }\n\n  ping() {\n    return this.sendMessagePromise(messages.ping());\n  }\n\n  sendMessage(message: MessageBase, commandId?: number): void {\n    if (DEBUG) {\n      console.log(\"Sending\", message);\n    }\n\n    if (!commandId) {\n      commandId = this._genCmdId();\n    }\n    message.id = commandId;\n\n    this.socket.send(JSON.stringify(message));\n  }\n\n  sendMessagePromise<Result>(message: MessageBase): Promise<Result> {\n    return new Promise((resolve, reject) => {\n      const commandId = this._genCmdId();\n      this.commands[commandId] = { resolve, reject };\n      this.sendMessage(message, commandId);\n    });\n  }\n\n  private _handleMessage(event: MessageEvent) {\n    const message: WebSocketResponse = JSON.parse(event.data);\n\n    if (DEBUG) {\n      console.log(\"Received\", message);\n    }\n\n    switch (message.type) {\n      case \"event\":\n        const eventInfo = this.commands[\n          message.id\n        ] as SubscribeEventCommmandInFlight;\n        eventInfo.eventCallback(message.event);\n        break;\n\n      case \"result\":\n        // If just sendMessage is used, we will not store promise for result\n        if (message.id in this.commands) {\n          const info = this.commands[message.id];\n\n          if (message.success) {\n            info.resolve(message.result);\n\n            // Don't remove event subscriptions.\n            if (!(\"eventCallback\" in info)) {\n              delete this.commands[message.id];\n            }\n          } else {\n            info.reject(message.error);\n            delete this.commands[message.id];\n          }\n        }\n        break;\n\n      case \"pong\":\n        const pongInfo = this.commands[message.id] as CommandWithAnswerInFlight;\n        pongInfo.resolve();\n        delete this.commands[message.id];\n        break;\n\n      default:\n        if (DEBUG) {\n          console.warn(\"Unhandled message\", message);\n        }\n    }\n  }\n\n  private _handleClose(ev: CloseEvent) {\n    // Reject in-flight sendMessagePromise requests\n    Object.keys(this.commands).forEach(id => {\n      const info: CommandInFlight = this.commands[id];\n\n      // We don't cancel subscribeEvents commands in flight\n      // as we will be able to recover them.\n      if (!(\"eventCallback\" in info)) {\n        info.reject(messages.error(ERR_CONNECTION_LOST, \"Connection lost\"));\n      }\n    });\n\n    if (this.closeRequested) {\n      return;\n    }\n\n    this.fireEvent(\"disconnected\");\n\n    // Disable setupRetry, we control it here with auto-backoff\n    const options = Object.assign({}, this.options, { setupRetry: 0 });\n\n    const reconnect = (tries: number) => {\n      setTimeout(async () => {\n        if (DEBUG) {\n          console.log(\"Trying to reconnect\");\n        }\n        try {\n          const socket = await options.createSocket(options);\n          this.setSocket(socket);\n        } catch (err) {\n          if (err === ERR_INVALID_AUTH) {\n            this.fireEvent(\"reconnect-error\", err);\n          } else {\n            reconnect(tries + 1);\n          }\n        }\n      }, Math.min(tries, 5) * 1000);\n    };\n\n    reconnect(0);\n  }\n\n  private _genCmdId() {\n    return ++this.commandId;\n  }\n}\n","import { Error } from \"./types\";\n\nexport function auth(accessToken: string) {\n  return {\n    type: \"auth\",\n    access_token: accessToken\n  };\n}\n\nexport function states() {\n  return {\n    type: \"get_states\"\n  };\n}\n\nexport function config() {\n  return {\n    type: \"get_config\"\n  };\n}\n\nexport function services() {\n  return {\n    type: \"get_services\"\n  };\n}\n\nexport function user() {\n  return {\n    type: \"auth/current_user\"\n  };\n}\n\ntype ServiceCallMessage = {\n  type: \"call_service\";\n  domain: string;\n  service: string;\n  service_data?: object;\n};\n\nexport function callService(\n  domain: string,\n  service: string,\n  serviceData?: object\n) {\n  const message: ServiceCallMessage = {\n    type: \"call_service\",\n    domain,\n    service\n  };\n\n  if (serviceData) {\n    message.service_data = serviceData;\n  }\n\n  return message;\n}\n\ntype SubscribeEventMessage = {\n  type: \"subscribe_events\";\n  event_type?: string;\n};\n\nexport function subscribeEvents(eventType?: string) {\n  const message: SubscribeEventMessage = {\n    type: \"subscribe_events\"\n  };\n\n  if (eventType) {\n    message.event_type = eventType;\n  }\n\n  return message;\n}\n\nexport function unsubscribeEvents(subscription: number) {\n  return {\n    type: \"unsubscribe_events\",\n    subscription\n  };\n}\n\nexport function ping() {\n  return {\n    type: \"ping\"\n  };\n}\n\nexport function error(code: Error, message: string) {\n  return {\n    type: \"result\",\n    success: false,\n    error: {\n      code,\n      message\n    }\n  };\n}\n","import { parseQuery } from \"./util\";\nimport { ERR_HASS_HOST_REQUIRED, ERR_INVALID_AUTH } from \"./errors\";\n\nexport type AuthData = {\n  hassUrl: string;\n  clientId: string;\n  expires: number;\n  refresh_token: string;\n  access_token: string;\n  expires_in: number;\n};\n\nexport type SaveTokensFunc = (data: AuthData | null) => void;\nexport type LoadTokensFunc = () => Promise<AuthData | null | undefined>;\n\nexport type getAuthOptions = {\n  hassUrl?: string;\n  clientId?: string;\n  redirectUrl?: string;\n  saveTokens?: SaveTokensFunc;\n  loadTokens?: LoadTokensFunc;\n};\n\ntype QueryCallbackData =\n  | {}\n  | {\n      state: string;\n      code: string;\n      auth_callback: string;\n    };\n\ntype OAuthState = {\n  hassUrl: string;\n  clientId: string;\n};\n\ntype AuthorizationCodeRequest = {\n  grant_type: \"authorization_code\";\n  code: string;\n};\n\ntype RefreshTokenRequest = {\n  grant_type: \"refresh_token\";\n  refresh_token: string;\n};\n\nexport const genClientId = (): string =>\n  `${location.protocol}//${location.host}/`;\n\nexport const genExpires = (expires_in: number): number => {\n  return expires_in * 1000 + Date.now();\n};\n\nfunction genRedirectUrl() {\n  // Get current url but without # part.\n  const { protocol, host, pathname, search } = location;\n  return `${protocol}//${host}${pathname}${search}`;\n}\n\nfunction genAuthorizeUrl(\n  hassUrl: string,\n  clientId: string,\n  redirectUrl: string,\n  state: string\n) {\n  let authorizeUrl = `${hassUrl}/auth/authorize?response_type=code&client_id=${encodeURIComponent(\n    clientId\n  )}&redirect_uri=${encodeURIComponent(redirectUrl)}`;\n\n  if (state) {\n    authorizeUrl += `&state=${encodeURIComponent(state)}`;\n  }\n  return authorizeUrl;\n}\n\nfunction redirectAuthorize(\n  hassUrl: string,\n  clientId: string,\n  redirectUrl: string,\n  state: string\n) {\n  // Add either ?auth_callback=1 or &auth_callback=1\n  redirectUrl += (redirectUrl.includes(\"?\") ? \"&\" : \"?\") + \"auth_callback=1\";\n\n  document.location!.href = genAuthorizeUrl(\n    hassUrl,\n    clientId,\n    redirectUrl,\n    state\n  );\n}\n\nasync function tokenRequest(\n  hassUrl: string,\n  clientId: string,\n  data: AuthorizationCodeRequest | RefreshTokenRequest\n) {\n  const formData = new FormData();\n  formData.append(\"client_id\", clientId);\n  Object.keys(data).forEach(key => {\n    formData.append(key, data[key]);\n  });\n\n  const resp = await fetch(`${hassUrl}/auth/token`, {\n    method: \"POST\",\n    credentials: \"same-origin\",\n    body: formData\n  });\n\n  if (!resp.ok) {\n    throw resp.status === 400 /* auth invalid */ ||\n    resp.status === 403 /* user not active */\n      ? ERR_INVALID_AUTH\n      : new Error(\"Unable to fetch tokens\");\n  }\n\n  const tokens: AuthData = await resp.json();\n  tokens.hassUrl = hassUrl;\n  tokens.clientId = clientId;\n  tokens.expires = genExpires(tokens.expires_in);\n  return tokens;\n}\n\nfunction fetchToken(hassUrl: string, clientId: string, code: string) {\n  return tokenRequest(hassUrl, clientId, {\n    code,\n    grant_type: \"authorization_code\"\n  });\n}\n\nfunction encodeOAuthState(state: OAuthState): string {\n  return btoa(JSON.stringify(state));\n}\n\nfunction decodeOAuthState(encoded: string): OAuthState {\n  return JSON.parse(atob(encoded));\n}\n\nexport class Auth {\n  private _saveTokens?: SaveTokensFunc;\n  data: AuthData;\n\n  constructor(data: AuthData, saveTokens?: SaveTokensFunc) {\n    this.data = data;\n    this._saveTokens = saveTokens;\n  }\n\n  get wsUrl() {\n    // Convert from http:// -> ws://, https:// -> wss://\n    return `ws${this.data.hassUrl.substr(4)}/api/websocket`;\n  }\n\n  get accessToken() {\n    return this.data.access_token;\n  }\n\n  get expired() {\n    return Date.now() > this.data.expires;\n  }\n\n  /**\n   * Refresh the access token.\n   */\n  async refreshAccessToken() {\n    const data = await tokenRequest(this.data.hassUrl, this.data.clientId, {\n      grant_type: \"refresh_token\",\n      refresh_token: this.data.refresh_token\n    });\n    // Access token response does not contain refresh token.\n    data.refresh_token = this.data.refresh_token;\n    this.data = data;\n    if (this._saveTokens) this._saveTokens(data);\n  }\n\n  /**\n   * Revoke the refresh & access tokens.\n   */\n  async revoke() {\n    const formData = new FormData();\n    formData.append(\"action\", \"revoke\");\n    formData.append(\"token\", this.data.refresh_token);\n\n    // There is no error checking, as revoke will always return 200\n    await fetch(`${this.data.hassUrl}/auth/token`, {\n      method: \"POST\",\n      credentials: \"same-origin\",\n      body: formData\n    });\n\n    if (this._saveTokens) {\n      this._saveTokens(null);\n    }\n  }\n}\n\nexport async function getAuth(options: getAuthOptions = {}): Promise<Auth> {\n  let data: AuthData | null | undefined;\n\n  // Check if we came back from an authorize redirect\n  const query = parseQuery<QueryCallbackData>(location.search.substr(1));\n\n  // Check if we got redirected here from authorize page\n  if (\"auth_callback\" in query) {\n    // Restore state\n    const state = decodeOAuthState(query.state);\n    try {\n      data = await fetchToken(state.hassUrl, state.clientId, query.code);\n      if (options.saveTokens) options.saveTokens(data);\n    } catch (err) {\n      // Do we want to tell user we were unable to fetch tokens?\n      // For now we don't do anything, having rest of code pick it up.\n      console.log(\"Unable to fetch access token\", err);\n    }\n  }\n\n  // Check for stored tokens\n  if (!data && options.loadTokens) {\n    data = await options.loadTokens();\n  }\n\n  if (data) {\n    return new Auth(data, options.saveTokens);\n  }\n\n  let hassUrl = options.hassUrl;\n\n  if (hassUrl === undefined) {\n    throw ERR_HASS_HOST_REQUIRED;\n  }\n\n  // Strip trailing slash.\n  if (hassUrl[hassUrl.length - 1] === \"/\") {\n    hassUrl = hassUrl.substr(0, hassUrl.length - 1);\n  }\n  const clientId = options.clientId || genClientId();\n  const redirectUrl = options.redirectUrl || genRedirectUrl();\n\n  // If no tokens found but a hassUrl was passed in, let's go get some tokens!\n  redirectAuthorize(\n    hassUrl,\n    clientId,\n    redirectUrl,\n    encodeOAuthState({\n      hassUrl,\n      clientId\n    })\n  );\n  // Just don't resolve while we navigate to next page\n  return new Promise<Auth>(() => {});\n}\n","export function parseQuery<T>(queryString: string) {\n  const query: any = {};\n  const items = queryString.split(\"&\");\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i].split(\"=\");\n    const key = decodeURIComponent(item[0]);\n    const value = item.length > 1 ? decodeURIComponent(item[1]) : undefined;\n    query[key] = value;\n  }\n  return query as T;\n}\n","import { UnsubscribeFunc } from \"./types\";\n\n// (c) Jason Miller\n// Unistore - MIT license\n// And then adopted to our needs + typescript\n\ntype Listener<State> = (state: State) => void;\ntype Action<State> = (\n  state: State,\n  ...args: any[]\n) => Partial<State> | Promise<Partial<State>> | null;\ntype BoundAction<State> = (...args: any[]) => void;\n\nexport type Store<State> = {\n  state: State | undefined;\n  action(action: Action<State>): BoundAction<State>;\n  setState(update: Partial<State>, overwrite?: boolean): void;\n  subscribe(listener: Listener<State>): UnsubscribeFunc;\n};\n\nexport const createStore = <State>(state?: State): Store<State> => {\n  let listeners: Listener<State>[] = [];\n\n  function unsubscribe(listener: Listener<State> | null) {\n    let out = [];\n    for (let i = 0; i < listeners.length; i++) {\n      if (listeners[i] === listener) {\n        listener = null;\n      } else {\n        out.push(listeners[i]);\n      }\n    }\n    listeners = out;\n  }\n\n  function setState(update: Partial<State>, overwrite: boolean): void {\n    state = overwrite ? (update as State) : Object.assign({}, state, update);\n    let currentListeners = listeners;\n    for (let i = 0; i < currentListeners.length; i++) {\n      currentListeners[i](state);\n    }\n  }\n\n  /**\n   * An observable state container, returned from {@link createStore}\n   * @name store\n   */\n\n  return {\n    get state() {\n      return state;\n    },\n\n    /**\n     * Create a bound copy of the given action function.\n     * The bound returned function invokes action() and persists the result back to the store.\n     * If the return value of `action` is a Promise, the resolved value will be used as state.\n     * @param {Function} action\tAn action of the form `action(state, ...args) -> stateUpdate`\n     * @returns {Function} boundAction()\n     */\n    action(action: Action<State>): BoundAction<State> {\n      function apply(result: Partial<State>) {\n        setState(result, false);\n      }\n\n      // Note: perf tests verifying this implementation: https://esbench.com/bench/5a295e6299634800a0349500\n      return function() {\n        let args = [state];\n        for (let i = 0; i < arguments.length; i++) args.push(arguments[i]);\n        // @ts-ignore\n        let ret = action.apply(this, args);\n        if (ret != null) {\n          if (ret.then) return ret.then(apply);\n          return apply(ret);\n        }\n      };\n    },\n\n    /**\n     * Apply a partial state object to the current state, invoking registered listeners.\n     * @param {Object} update\t\t\t\tAn object with properties to be merged into state\n     * @param {Boolean} [overwrite=false]\tIf `true`, update will replace state instead of being merged into it\n     */\n    setState,\n\n    /**\n     * Register a listener function to be called whenever state is changed. Returns an `unsubscribe()` function.\n     * @param {Function} listener\tA function to call when state changes. Gets passed the new state.\n     * @returns {Function} unsubscribe()\n     */\n    subscribe(listener: Listener<State>) {\n      listeners.push(listener);\n      return () => {\n        unsubscribe(listener);\n      };\n    }\n\n    // /**\n    //  * Remove a previously-registered listener function.\n    //  * @param {Function} listener\tThe callback previously passed to `subscribe()` that should be removed.\n    //  * @function\n    //  */\n    // unsubscribe,\n  };\n};\n","import { Store, createStore } from \"./store\";\nimport { Connection } from \"./connection\";\nimport { UnsubscribeFunc } from \"./types\";\n\nexport type Collection<State> = {\n  state: State;\n  refresh(): Promise<void>;\n  subscribe(subscriber: (state: State) => void): UnsubscribeFunc;\n};\n\nexport const getCollection = <State>(\n  conn: Connection,\n  key: string,\n  fetchCollection: (conn: Connection) => Promise<State>,\n  subscribeUpdates?: (\n    conn: Connection,\n    store: Store<State>\n  ) => Promise<UnsubscribeFunc>\n): Collection<State> => {\n  if (conn[key]) {\n    return conn[key];\n  }\n\n  let active = 0;\n  let unsubProm: Promise<UnsubscribeFunc>;\n  let store = createStore<State>();\n\n  const refresh = () =>\n    fetchCollection(conn).then(state => store.setState(state, true));\n\n  conn[key] = {\n    get state() {\n      return store.state;\n    },\n\n    refresh,\n\n    subscribe(subscriber: (state: State) => void): UnsubscribeFunc {\n      if (!active) {\n        active++;\n\n        // Subscribe to changes\n        if (subscribeUpdates) {\n          unsubProm = subscribeUpdates(conn, store);\n        }\n\n        // Fetch when connection re-established.\n        conn.addEventListener(\"ready\", refresh);\n\n        refresh().catch((err: unknown) => {\n          // Swallow errors if socket is connecting, closing or closed.\n          // We will automatically call refresh again when we re-establish the connection.\n          // Using conn.socket.OPEN instead of WebSocket for better node support\n          if (conn.socket.readyState == conn.socket.OPEN) {\n            throw err;\n          }\n        });\n      }\n\n      const unsub = store.subscribe(subscriber);\n\n      if (store.state !== undefined) {\n        subscriber(store.state);\n      }\n\n      return () => {\n        unsub();\n        active--;\n        if (!active) {\n          // Unsubscribe from changes\n          if (unsubProm)\n            unsubProm.then(unsub => {\n              unsub();\n            });\n          conn.removeEventListener(\"ready\", refresh);\n        }\n      };\n    }\n  };\n\n  return conn[key];\n};\n\n// Legacy name. It gets a collection and subscribes.\nexport const createCollection = <State>(\n  key: string,\n  fetchCollection: (conn: Connection) => Promise<State>,\n  subscribeUpdates:\n    | ((conn: Connection, store: Store<State>) => Promise<UnsubscribeFunc>)\n    | undefined,\n  conn: Connection,\n  onChange: (state: State) => void\n): UnsubscribeFunc =>\n  getCollection(conn, key, fetchCollection, subscribeUpdates).subscribe(\n    onChange\n  );\n","import { Connection } from \"./connection\";\nimport * as messages from \"./messages\";\nimport { HassEntity, HassServices, HassConfig } from \"./types\";\n\nexport const getStates = (connection: Connection) =>\n  connection.sendMessagePromise<HassEntity[]>(messages.states());\n\nexport const getServices = (connection: Connection) =>\n  connection.sendMessagePromise<HassServices>(messages.services());\n\nexport const getConfig = (connection: Connection) =>\n  connection.sendMessagePromise<HassConfig>(messages.config());\n\nexport const getUser = (connection: Connection) =>\n  connection.sendMessagePromise<HassConfig>(messages.user());\n\nexport const callService = (\n  connection: Connection,\n  domain: string,\n  service: string,\n  serviceData?: object\n) =>\n  connection.sendMessagePromise(\n    messages.callService(domain, service, serviceData)\n  );\n","import { getCollection } from \"./collection\";\nimport { HassConfig, UnsubscribeFunc } from \"./types\";\nimport { Connection } from \"./connection\";\nimport { Store } from \"./store\";\nimport { getConfig } from \"./commands\";\n\ntype ComponentLoadedEvent = {\n  data: {\n    component: string;\n  };\n};\n\nfunction processComponentLoaded(\n  state: HassConfig,\n  event: ComponentLoadedEvent\n): Partial<HassConfig> | null {\n  if (state === undefined) return null;\n\n  return {\n    components: state.components.concat(event.data.component)\n  };\n}\n\nconst fetchConfig = (conn: Connection) => getConfig(conn);\nconst subscribeUpdates = (conn: Connection, store: Store<HassConfig>) =>\n  conn.subscribeEvents(\n    store.action(processComponentLoaded),\n    \"component_loaded\"\n  );\n\nconst configColl = (conn: Connection) =>\n  getCollection(conn, \"_cnf\", fetchConfig, subscribeUpdates);\n\nexport const subscribeConfig = (\n  conn: Connection,\n  onChange: (state: HassConfig) => void\n): UnsubscribeFunc => configColl(conn).subscribe(onChange);\n","import { getCollection } from \"./collection\";\nimport { HassServices, HassDomainServices, UnsubscribeFunc } from \"./types\";\nimport { Connection } from \"./connection\";\nimport { Store } from \"./store\";\nimport { getServices } from \"./commands\";\n\ntype ServiceRegisteredEvent = {\n  data: {\n    domain: string;\n    service: string;\n  };\n};\n\ntype ServiceRemovedEvent = {\n  data: {\n    domain: string;\n    service: string;\n  };\n};\n\nfunction processServiceRegistered(\n  state: HassServices,\n  event: ServiceRegisteredEvent\n) {\n  if (state === undefined) return null;\n\n  const { domain, service } = event.data;\n\n  const domainInfo = Object.assign({}, state[domain], {\n    [service]: { description: \"\", fields: {} }\n  });\n\n  return { [domain]: domainInfo };\n}\n\nfunction processServiceRemoved(\n  state: HassServices,\n  event: ServiceRemovedEvent\n) {\n  if (state === undefined) return null;\n\n  const { domain, service } = event.data;\n  const curDomainInfo = state[domain];\n\n  if (!curDomainInfo || !(service in curDomainInfo)) return null;\n\n  const domainInfo: HassDomainServices = {};\n  Object.keys(curDomainInfo).forEach(sKey => {\n    if (sKey !== service) domainInfo[sKey] = curDomainInfo[sKey];\n  });\n\n  return { [domain]: domainInfo };\n}\n\nconst fetchServices = (conn: Connection) => getServices(conn);\nconst subscribeUpdates = (conn: Connection, store: Store<HassServices>) =>\n  Promise.all([\n    conn.subscribeEvents<ServiceRegisteredEvent>(\n      store.action(processServiceRegistered),\n      \"service_registered\"\n    ),\n    conn.subscribeEvents<ServiceRemovedEvent>(\n      store.action(processServiceRemoved),\n      \"service_removed\"\n    )\n  ]).then(unsubs => () => unsubs.forEach(fn => fn()));\n\nconst servicesColl = (conn: Connection) =>\n  getCollection(conn, \"_srv\", fetchServices, subscribeUpdates);\n\nexport const subscribeServices = (\n  conn: Connection,\n  onChange: (state: HassServices) => void\n): UnsubscribeFunc => servicesColl(conn).subscribe(onChange);\n","import { getCollection } from \"./collection\";\nimport { HassEntities, StateChangedEvent, UnsubscribeFunc } from \"./types\";\nimport { Connection } from \"./connection\";\nimport { Store } from \"./store\";\nimport { getStates } from \"./commands\";\n\nfunction processEvent(store: Store<HassEntities>, event: StateChangedEvent) {\n  const state = store.state;\n  if (state === undefined) return;\n\n  const { entity_id, new_state } = event.data;\n  if (new_state) {\n    store.setState({ [new_state.entity_id]: new_state });\n  } else {\n    const newEntities = Object.assign({}, state);\n    delete newEntities[entity_id];\n    store.setState(newEntities, true);\n  }\n}\n\nasync function fetchEntities(conn: Connection): Promise<HassEntities> {\n  const states = await getStates(conn);\n  const entities: HassEntities = {};\n  for (let i = 0; i < states.length; i++) {\n    const state = states[i];\n    entities[state.entity_id] = state;\n  }\n  return entities;\n}\n\nconst subscribeUpdates = (conn: Connection, store: Store<HassEntities>) =>\n  conn.subscribeEvents<StateChangedEvent>(\n    ev => processEvent(store, ev as StateChangedEvent),\n    \"state_changed\"\n  );\n\nexport const entitiesColl = (conn: Connection) =>\n  getCollection(conn, \"_ent\", fetchEntities, subscribeUpdates);\n\nexport const subscribeEntities = (\n  conn: Connection,\n  onChange: (state: HassEntities) => void\n): UnsubscribeFunc => entitiesColl(conn).subscribe(onChange);\n","import { ConnectionOptions } from \"./types\";\nimport { createSocket } from \"./socket\";\nimport { Connection } from \"./connection\";\n\nexport * from \"./auth\";\nexport * from \"./collection\";\nexport * from \"./connection\";\nexport * from \"./config\";\nexport * from \"./services\";\nexport * from \"./entities\";\nexport * from \"./errors\";\nexport * from \"./types\";\nexport * from \"./commands\";\n\nconst defaultConnectionOptions: ConnectionOptions = {\n  setupRetry: 0,\n  createSocket\n};\n\nexport async function createConnection(options?: Partial<ConnectionOptions>) {\n  const connOptions: ConnectionOptions = Object.assign(\n    {},\n    defaultConnectionOptions,\n    options\n  );\n  const socket = await connOptions.createSocket(connOptions);\n  const conn = new Connection(socket, connOptions);\n  return conn;\n}\n"],"names":["ERR_CANNOT_CONNECT","ERR_INVALID_AUTH","ERR_CONNECTION_LOST","ERR_HASS_HOST_REQUIRED","MSG_TYPE_AUTH_INVALID","MSG_TYPE_AUTH_OK","socket","options","this","commandId","commands","eventListeners","closeRequested","setSocket","Connection","oldSocket","addEventListener","ev","_this","_handleMessage","_handleClose","oldCommands_1","Object","keys","forEach","id","info","subscribeEvents","eventCallback","eventType","then","unsub","unsubscribe","resolve","fireEvent","callback","listeners","push","index","indexOf","splice","eventData","close","_genCmdId","Promise","reject","sendMessagePromise","subscription","type","_a","sendMessage","message","event_type","messages.subscribeEvents","err","send","JSON","stringify","event","parse","data","success","result","error","code","assign","setupRetry","reconnect","tries","setTimeout","createSocket","err_1","Math","min","genClientId","location","protocol","host","genExpires","expires_in","Date","now","redirectAuthorize","hassUrl","clientId","redirectUrl","state","includes","document","href","authorizeUrl","encodeURIComponent","genAuthorizeUrl","tokenRequest","formData","FormData","append","key","fetch","method","credentials","body","resp","ok","status","Error","json","tokens","expires","saveTokens","_saveTokens","Auth","substr","access_token","grant_type","refresh_token","getAuth","query","queryString","items","split","i","length","item","decodeURIComponent","value","undefined","parseQuery","search","atob","fetchToken","console","log","loadTokens","btoa","encodeOAuthState","createStore","setState","update","overwrite","currentListeners","action","apply","args","arguments","ret","subscribe","listener","out","getCollection","conn","fetchCollection","subscribeUpdates","unsubProm","active","store","refresh","subscriber","catch","readyState","OPEN","removeEventListener","createCollection","onChange","getStates","connection","getServices","getConfig","getUser","callService","domain","service","serviceData","service_data","messages.callService","processComponentLoaded","components","concat","component","fetchConfig","subscribeConfig","configColl","processServiceRegistered","_c","domainInfo","description","fields","processServiceRemoved","_b","curDomainInfo","sKey","fetchServices","all","unsubs","fn","subscribeServices","servicesColl","fetchEntities","states","entities","entity_id","new_state","newEntities","processEvent","entitiesColl","subscribeEntities","defaultConnectionOptions","auth","url","wsUrl","connect","triesLeft","promResolve","promReject","WebSocket","invalidAuth","closeMessage","newTries","handleOpen","expired","refreshAccessToken","accessToken","handleMessage","createConnection","connOptions"],"mappings":"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"}