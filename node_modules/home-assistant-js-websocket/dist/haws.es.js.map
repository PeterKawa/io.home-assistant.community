{"version":3,"file":"haws.es.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../lib/errors.ts","../lib/connection.ts","../lib/messages.ts","../lib/auth.ts","../lib/util.ts","../lib/store.ts","../lib/collection.ts","../lib/commands.ts","../lib/config.ts","../lib/services.ts","../lib/entities.ts","../lib/index.ts","../lib/socket.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = (function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof Symbol !== \"undefined\") {\n\t\tvar iteratorSymbol = Symbol.iterator;\n\t\tif (iteratorSymbol && (iteratorSymbol in target)) {\n\t\t\tvar iterator = target[iteratorSymbol](), step, pact, reject;\n\t\t\tfunction _cycle(result) {\n\t\t\t\ttry {\n\t\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (pact) {\n\t\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpact = result;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t\t\t}\n\t\t\t}\n\t\t\t_cycle();\n\t\t\tif (iterator.return) {\n\t\t\t\tvar _fixup = function(value) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\t\titerator.return();\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\tif (pact && pact.then) {\n\t\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t_fixup();\n\t\t\t}\n\t\t\treturn pact;\n\t\t}\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"value is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof Symbol !== \"undefined\") {\n\t\tvar asyncIteratorSymbol = Symbol.asyncIterator;\n\t\tif (asyncIteratorSymbol && (asyncIteratorSymbol in target)) {\n\t\t\tvar pact = new _Pact();\n\t\t\tvar iterator = target[asyncIteratorSymbol]();\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t\treturn pact;\n\t\t\tfunction _resumeAfterBody(result) {\n\t\t\t\tif (check && !check()) {\n\t\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t\t}\n\t\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t\t}\n\t\t\tfunction _resumeAfterNext(step) {\n\t\t\t\tif (step.done) {\n\t\t\t\t\t_settle(pact, 1);\n\t\t\t\t} else {\n\t\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfunction _reject(error) {\n\t\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t\t}\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, value);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = (function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype[Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))] = function() {\n\t\treturn this;\n\t};\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\t_entry(_this).then(returnValue, function(error) {\n\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","export const ERR_CANNOT_CONNECT = 1;\nexport const ERR_INVALID_AUTH = 2;\nexport const ERR_CONNECTION_LOST = 3;\nexport const ERR_HASS_HOST_REQUIRED = 4;\n","/**\n * Connection that wraps a socket and provides an interface to interact with\n * the Home Assistant websocket API.\n */\nimport * as messages from \"./messages\";\nimport { ERR_INVALID_AUTH, ERR_CONNECTION_LOST } from \"./errors\";\nimport { ConnectionOptions, HassEvent, MessageBase } from \"./types\";\n\nconst DEBUG = false;\n\nexport type ConnectionEventListener = (\n  conn: Connection,\n  eventData?: any\n) => void;\n\ntype Events = \"ready\" | \"disconnected\" | \"reconnect-error\";\n\ntype WebSocketPongResponse = {\n  id: number;\n  type: \"pong\";\n};\n\ntype WebSocketEventResponse = {\n  id: number;\n  type: \"event\";\n  event: HassEvent;\n};\n\ntype WebSocketResultResponse = {\n  id: number;\n  type: \"result\";\n  success: true;\n  result: any;\n};\n\ntype WebSocketResultErrorResponse = {\n  id: number;\n  type: \"result\";\n  success: false;\n  error: {\n    code: string;\n    message: string;\n  };\n};\n\ntype WebSocketResponse =\n  | WebSocketPongResponse\n  | WebSocketEventResponse\n  | WebSocketResultResponse\n  | WebSocketResultErrorResponse;\n\ntype SubscriptionUnsubscribe = () => Promise<void>;\n\ninterface SubscribeEventCommmandInFlight<T> {\n  resolve: (result?: any) => void;\n  reject: (err: any) => void;\n  callback: (ev: T) => void;\n  subscribe: () => Promise<SubscriptionUnsubscribe>;\n  unsubscribe: SubscriptionUnsubscribe;\n}\n\ntype CommandWithAnswerInFlight = {\n  resolve: (result?: any) => void;\n  reject: (err: any) => void;\n};\n\ntype CommandInFlight =\n  | SubscribeEventCommmandInFlight<any>\n  | CommandWithAnswerInFlight;\n\nexport class Connection {\n  options: ConnectionOptions;\n  commandId: number;\n  commands: {\n    [commandId: number]: CommandInFlight;\n  };\n  eventListeners: {\n    [eventType: string]: ConnectionEventListener[];\n  };\n  closeRequested: boolean;\n  // @ts-ignore: incorrectly claiming it's not set in constructor.\n  socket: WebSocket;\n\n  constructor(socket: WebSocket, options: ConnectionOptions) {\n    // connection options\n    //  - setupRetry: amount of ms to retry when unable to connect on initial setup\n    //  - createSocket: create a new Socket connection\n    this.options = options;\n    // id if next command to send\n    this.commandId = 1;\n    // info about active subscriptions and commands in flight\n    this.commands = {};\n    // map of event listeners\n    this.eventListeners = {};\n    // true if a close is requested by the user\n    this.closeRequested = false;\n\n    this.setSocket(socket);\n  }\n\n  setSocket(socket: WebSocket) {\n    const oldSocket = this.socket;\n    this.socket = socket;\n    socket.addEventListener(\"message\", ev => this._handleMessage(ev));\n    socket.addEventListener(\"close\", ev => this._handleClose(ev));\n\n    if (oldSocket) {\n      const oldCommands = this.commands;\n\n      // reset to original state\n      this.commandId = 1;\n      this.commands = {};\n\n      Object.keys(oldCommands).forEach(id => {\n        const info: CommandInFlight = oldCommands[id];\n\n        if (\"subscribe\" in info) {\n          info.subscribe().then(unsub => {\n            info.unsubscribe = unsub;\n            // We need to resolve this in case it wasn't resolved yet.\n            // This allows us to subscribe while we're disconnected\n            // and recover properly.\n            info.resolve();\n          });\n        }\n      });\n\n      this.fireEvent(\"ready\");\n    }\n  }\n\n  addEventListener(eventType: Events, callback: ConnectionEventListener) {\n    let listeners = this.eventListeners[eventType];\n\n    if (!listeners) {\n      listeners = this.eventListeners[eventType] = [];\n    }\n\n    listeners.push(callback);\n  }\n\n  removeEventListener(eventType: Events, callback: ConnectionEventListener) {\n    const listeners = this.eventListeners[eventType];\n\n    if (!listeners) {\n      return;\n    }\n\n    const index = listeners.indexOf(callback);\n\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n  }\n\n  fireEvent(eventType: Events, eventData?: any) {\n    (this.eventListeners[eventType] || []).forEach(callback =>\n      callback(this, eventData)\n    );\n  }\n\n  close() {\n    this.closeRequested = true;\n    this.socket.close();\n  }\n\n  /**\n   * Subscribe to a specific or all events.\n   *\n   * @param callback Callback  to be called when a new event fires\n   * @param eventType\n   * @returns promise that resolves to an unsubscribe function\n   */\n  async subscribeEvents<EventType>(\n    callback: (ev: EventType) => void,\n    eventType?: string\n  ): Promise<SubscriptionUnsubscribe> {\n    return this.subscribeMessage(callback, messages.subscribeEvents(eventType));\n  }\n\n  ping() {\n    return this.sendMessagePromise(messages.ping());\n  }\n\n  sendMessage(message: MessageBase, commandId?: number): void {\n    if (DEBUG) {\n      console.log(\"Sending\", message);\n    }\n\n    if (!commandId) {\n      commandId = this._genCmdId();\n    }\n    message.id = commandId;\n\n    this.socket.send(JSON.stringify(message));\n  }\n\n  sendMessagePromise<Result>(message: MessageBase): Promise<Result> {\n    return new Promise((resolve, reject) => {\n      const commandId = this._genCmdId();\n      this.commands[commandId] = { resolve, reject };\n      this.sendMessage(message, commandId);\n    });\n  }\n\n  /**\n   * Call a websocket command that starts a subscription on the backend.\n   *\n   * @param message the message to start the subscription\n   * @param callback the callback to be called when a new item arrives\n   * @returns promise that resolves to an unsubscribe function\n   */\n  async subscribeMessage<Result>(\n    callback: (result: Result) => void,\n    subscribeMessage: MessageBase\n  ): Promise<SubscriptionUnsubscribe> {\n    // Command ID that will be used\n    const commandId = this._genCmdId();\n    let info: SubscribeEventCommmandInFlight<Result>;\n\n    await new Promise((resolve, reject) => {\n      // We store unsubscribe on info object. That way we can overwrite it in case\n      // we get disconnected and we have to subscribe again.\n      info = this.commands[commandId] = {\n        resolve,\n        reject,\n        callback,\n        subscribe: () => this.subscribeMessage(callback, subscribeMessage),\n        unsubscribe: async () => {\n          await this.sendMessagePromise(messages.unsubscribeEvents(commandId));\n          delete this.commands[commandId];\n        }\n      };\n\n      try {\n        this.sendMessage(subscribeMessage, commandId);\n      } catch (err) {\n        // Happens when the websocket is already closing.\n        // Don't have to handle the error, reconnect logic will pick it up.\n      }\n    });\n\n    return () => info.unsubscribe();\n  }\n\n  private _handleMessage(event: MessageEvent) {\n    const message: WebSocketResponse = JSON.parse(event.data);\n\n    if (DEBUG) {\n      console.log(\"Received\", message);\n    }\n\n    switch (message.type) {\n      case \"event\":\n        const eventInfo = this.commands[\n          message.id\n        ] as SubscribeEventCommmandInFlight<any>;\n        eventInfo.callback(message.event);\n        break;\n\n      case \"result\":\n        // If just sendMessage is used, we will not store promise for result\n        if (message.id in this.commands) {\n          const info = this.commands[message.id];\n\n          if (message.success) {\n            info.resolve(message.result);\n\n            // Don't remove subscriptions.\n            if (!(\"subscribe\" in info)) {\n              delete this.commands[message.id];\n            }\n          } else {\n            info.reject(message.error);\n            delete this.commands[message.id];\n          }\n        }\n        break;\n\n      case \"pong\":\n        const pongInfo = this.commands[message.id] as CommandWithAnswerInFlight;\n        pongInfo.resolve();\n        delete this.commands[message.id];\n        break;\n\n      default:\n        if (DEBUG) {\n          console.warn(\"Unhandled message\", message);\n        }\n    }\n  }\n\n  private _handleClose(ev: CloseEvent) {\n    // Reject in-flight sendMessagePromise requests\n    Object.keys(this.commands).forEach(id => {\n      const info: CommandInFlight = this.commands[id];\n\n      // We don't cancel subscribeEvents commands in flight\n      // as we will be able to recover them.\n      if (!(\"subscribe\" in info)) {\n        info.reject(messages.error(ERR_CONNECTION_LOST, \"Connection lost\"));\n      }\n    });\n\n    if (this.closeRequested) {\n      return;\n    }\n\n    this.fireEvent(\"disconnected\");\n\n    // Disable setupRetry, we control it here with auto-backoff\n    const options = Object.assign({}, this.options, { setupRetry: 0 });\n\n    const reconnect = (tries: number) => {\n      setTimeout(async () => {\n        if (DEBUG) {\n          console.log(\"Trying to reconnect\");\n        }\n        try {\n          const socket = await options.createSocket(options);\n          this.setSocket(socket);\n        } catch (err) {\n          if (err === ERR_INVALID_AUTH) {\n            this.fireEvent(\"reconnect-error\", err);\n          } else {\n            reconnect(tries + 1);\n          }\n        }\n      }, Math.min(tries, 5) * 1000);\n    };\n\n    reconnect(0);\n  }\n\n  private _genCmdId() {\n    return ++this.commandId;\n  }\n}\n","import { Error } from \"./types\";\n\nexport function auth(accessToken: string) {\n  return {\n    type: \"auth\",\n    access_token: accessToken\n  };\n}\n\nexport function states() {\n  return {\n    type: \"get_states\"\n  };\n}\n\nexport function config() {\n  return {\n    type: \"get_config\"\n  };\n}\n\nexport function services() {\n  return {\n    type: \"get_services\"\n  };\n}\n\nexport function user() {\n  return {\n    type: \"auth/current_user\"\n  };\n}\n\ntype ServiceCallMessage = {\n  type: \"call_service\";\n  domain: string;\n  service: string;\n  service_data?: object;\n};\n\nexport function callService(\n  domain: string,\n  service: string,\n  serviceData?: object\n) {\n  const message: ServiceCallMessage = {\n    type: \"call_service\",\n    domain,\n    service\n  };\n\n  if (serviceData) {\n    message.service_data = serviceData;\n  }\n\n  return message;\n}\n\ntype SubscribeEventMessage = {\n  type: \"subscribe_events\";\n  event_type?: string;\n};\n\nexport function subscribeEvents(eventType?: string) {\n  const message: SubscribeEventMessage = {\n    type: \"subscribe_events\"\n  };\n\n  if (eventType) {\n    message.event_type = eventType;\n  }\n\n  return message;\n}\n\nexport function unsubscribeEvents(subscription: number) {\n  return {\n    type: \"unsubscribe_events\",\n    subscription\n  };\n}\n\nexport function ping() {\n  return {\n    type: \"ping\"\n  };\n}\n\nexport function error(code: Error, message: string) {\n  return {\n    type: \"result\",\n    success: false,\n    error: {\n      code,\n      message\n    }\n  };\n}\n","import { parseQuery } from \"./util\";\nimport { ERR_HASS_HOST_REQUIRED, ERR_INVALID_AUTH } from \"./errors\";\n\nexport type AuthData = {\n  hassUrl: string;\n  clientId: string;\n  expires: number;\n  refresh_token: string;\n  access_token: string;\n  expires_in: number;\n};\n\nexport type SaveTokensFunc = (data: AuthData | null) => void;\nexport type LoadTokensFunc = () => Promise<AuthData | null | undefined>;\n\nexport type getAuthOptions = {\n  hassUrl?: string;\n  clientId?: string;\n  redirectUrl?: string;\n  saveTokens?: SaveTokensFunc;\n  loadTokens?: LoadTokensFunc;\n};\n\ntype QueryCallbackData =\n  | {}\n  | {\n      state: string;\n      code: string;\n      auth_callback: string;\n    };\n\ntype OAuthState = {\n  hassUrl: string;\n  clientId: string;\n};\n\ntype AuthorizationCodeRequest = {\n  grant_type: \"authorization_code\";\n  code: string;\n};\n\ntype RefreshTokenRequest = {\n  grant_type: \"refresh_token\";\n  refresh_token: string;\n};\n\nexport const genClientId = (): string =>\n  `${location.protocol}//${location.host}/`;\n\nexport const genExpires = (expires_in: number): number => {\n  return expires_in * 1000 + Date.now();\n};\n\nfunction genRedirectUrl() {\n  // Get current url but without # part.\n  const { protocol, host, pathname, search } = location;\n  return `${protocol}//${host}${pathname}${search}`;\n}\n\nfunction genAuthorizeUrl(\n  hassUrl: string,\n  clientId: string,\n  redirectUrl: string,\n  state: string\n) {\n  let authorizeUrl = `${hassUrl}/auth/authorize?response_type=code&client_id=${encodeURIComponent(\n    clientId\n  )}&redirect_uri=${encodeURIComponent(redirectUrl)}`;\n\n  if (state) {\n    authorizeUrl += `&state=${encodeURIComponent(state)}`;\n  }\n  return authorizeUrl;\n}\n\nfunction redirectAuthorize(\n  hassUrl: string,\n  clientId: string,\n  redirectUrl: string,\n  state: string\n) {\n  // Add either ?auth_callback=1 or &auth_callback=1\n  redirectUrl += (redirectUrl.includes(\"?\") ? \"&\" : \"?\") + \"auth_callback=1\";\n\n  document.location!.href = genAuthorizeUrl(\n    hassUrl,\n    clientId,\n    redirectUrl,\n    state\n  );\n}\n\nasync function tokenRequest(\n  hassUrl: string,\n  clientId: string,\n  data: AuthorizationCodeRequest | RefreshTokenRequest\n) {\n  const formData = new FormData();\n  formData.append(\"client_id\", clientId);\n  Object.keys(data).forEach(key => {\n    formData.append(key, data[key]);\n  });\n\n  const resp = await fetch(`${hassUrl}/auth/token`, {\n    method: \"POST\",\n    credentials: \"same-origin\",\n    body: formData\n  });\n\n  if (!resp.ok) {\n    throw resp.status === 400 /* auth invalid */ ||\n    resp.status === 403 /* user not active */\n      ? ERR_INVALID_AUTH\n      : new Error(\"Unable to fetch tokens\");\n  }\n\n  const tokens: AuthData = await resp.json();\n  tokens.hassUrl = hassUrl;\n  tokens.clientId = clientId;\n  tokens.expires = genExpires(tokens.expires_in);\n  return tokens;\n}\n\nfunction fetchToken(hassUrl: string, clientId: string, code: string) {\n  return tokenRequest(hassUrl, clientId, {\n    code,\n    grant_type: \"authorization_code\"\n  });\n}\n\nfunction encodeOAuthState(state: OAuthState): string {\n  return btoa(JSON.stringify(state));\n}\n\nfunction decodeOAuthState(encoded: string): OAuthState {\n  return JSON.parse(atob(encoded));\n}\n\nexport class Auth {\n  private _saveTokens?: SaveTokensFunc;\n  data: AuthData;\n\n  constructor(data: AuthData, saveTokens?: SaveTokensFunc) {\n    this.data = data;\n    this._saveTokens = saveTokens;\n  }\n\n  get wsUrl() {\n    // Convert from http:// -> ws://, https:// -> wss://\n    return `ws${this.data.hassUrl.substr(4)}/api/websocket`;\n  }\n\n  get accessToken() {\n    return this.data.access_token;\n  }\n\n  get expired() {\n    return Date.now() > this.data.expires;\n  }\n\n  /**\n   * Refresh the access token.\n   */\n  async refreshAccessToken() {\n    const data = await tokenRequest(this.data.hassUrl, this.data.clientId, {\n      grant_type: \"refresh_token\",\n      refresh_token: this.data.refresh_token\n    });\n    // Access token response does not contain refresh token.\n    data.refresh_token = this.data.refresh_token;\n    this.data = data;\n    if (this._saveTokens) this._saveTokens(data);\n  }\n\n  /**\n   * Revoke the refresh & access tokens.\n   */\n  async revoke() {\n    const formData = new FormData();\n    formData.append(\"action\", \"revoke\");\n    formData.append(\"token\", this.data.refresh_token);\n\n    // There is no error checking, as revoke will always return 200\n    await fetch(`${this.data.hassUrl}/auth/token`, {\n      method: \"POST\",\n      credentials: \"same-origin\",\n      body: formData\n    });\n\n    if (this._saveTokens) {\n      this._saveTokens(null);\n    }\n  }\n}\n\nexport async function getAuth(options: getAuthOptions = {}): Promise<Auth> {\n  let data: AuthData | null | undefined;\n\n  // Check if we came back from an authorize redirect\n  const query = parseQuery<QueryCallbackData>(location.search.substr(1));\n\n  // Check if we got redirected here from authorize page\n  if (\"auth_callback\" in query) {\n    // Restore state\n    const state = decodeOAuthState(query.state);\n    try {\n      data = await fetchToken(state.hassUrl, state.clientId, query.code);\n      if (options.saveTokens) options.saveTokens(data);\n    } catch (err) {\n      // Do we want to tell user we were unable to fetch tokens?\n      // For now we don't do anything, having rest of code pick it up.\n      console.log(\"Unable to fetch access token\", err);\n    }\n  }\n\n  // Check for stored tokens\n  if (!data && options.loadTokens) {\n    data = await options.loadTokens();\n  }\n\n  if (data) {\n    return new Auth(data, options.saveTokens);\n  }\n\n  let hassUrl = options.hassUrl;\n\n  if (hassUrl === undefined) {\n    throw ERR_HASS_HOST_REQUIRED;\n  }\n\n  // Strip trailing slash.\n  if (hassUrl[hassUrl.length - 1] === \"/\") {\n    hassUrl = hassUrl.substr(0, hassUrl.length - 1);\n  }\n  const clientId = options.clientId || genClientId();\n  const redirectUrl = options.redirectUrl || genRedirectUrl();\n\n  // If no tokens found but a hassUrl was passed in, let's go get some tokens!\n  redirectAuthorize(\n    hassUrl,\n    clientId,\n    redirectUrl,\n    encodeOAuthState({\n      hassUrl,\n      clientId\n    })\n  );\n  // Just don't resolve while we navigate to next page\n  return new Promise<Auth>(() => {});\n}\n","export function parseQuery<T>(queryString: string) {\n  const query: any = {};\n  const items = queryString.split(\"&\");\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i].split(\"=\");\n    const key = decodeURIComponent(item[0]);\n    const value = item.length > 1 ? decodeURIComponent(item[1]) : undefined;\n    query[key] = value;\n  }\n  return query as T;\n}\n","import { UnsubscribeFunc } from \"./types\";\n\n// (c) Jason Miller\n// Unistore - MIT license\n// And then adopted to our needs + typescript\n\ntype Listener<State> = (state: State) => void;\ntype Action<State> = (\n  state: State,\n  ...args: any[]\n) => Partial<State> | Promise<Partial<State>> | null;\ntype BoundAction<State> = (...args: any[]) => void;\n\nexport type Store<State> = {\n  state: State | undefined;\n  action(action: Action<State>): BoundAction<State>;\n  setState(update: Partial<State>, overwrite?: boolean): void;\n  subscribe(listener: Listener<State>): UnsubscribeFunc;\n};\n\nexport const createStore = <State>(state?: State): Store<State> => {\n  let listeners: Listener<State>[] = [];\n\n  function unsubscribe(listener: Listener<State> | null) {\n    let out = [];\n    for (let i = 0; i < listeners.length; i++) {\n      if (listeners[i] === listener) {\n        listener = null;\n      } else {\n        out.push(listeners[i]);\n      }\n    }\n    listeners = out;\n  }\n\n  function setState(update: Partial<State>, overwrite: boolean): void {\n    state = overwrite ? (update as State) : Object.assign({}, state, update);\n    let currentListeners = listeners;\n    for (let i = 0; i < currentListeners.length; i++) {\n      currentListeners[i](state);\n    }\n  }\n\n  /**\n   * An observable state container, returned from {@link createStore}\n   * @name store\n   */\n\n  return {\n    get state() {\n      return state;\n    },\n\n    /**\n     * Create a bound copy of the given action function.\n     * The bound returned function invokes action() and persists the result back to the store.\n     * If the return value of `action` is a Promise, the resolved value will be used as state.\n     * @param {Function} action\tAn action of the form `action(state, ...args) -> stateUpdate`\n     * @returns {Function} boundAction()\n     */\n    action(action: Action<State>): BoundAction<State> {\n      function apply(result: Partial<State>) {\n        setState(result, false);\n      }\n\n      // Note: perf tests verifying this implementation: https://esbench.com/bench/5a295e6299634800a0349500\n      return function() {\n        let args = [state];\n        for (let i = 0; i < arguments.length; i++) args.push(arguments[i]);\n        // @ts-ignore\n        let ret = action.apply(this, args);\n        if (ret != null) {\n          if (ret.then) return ret.then(apply);\n          return apply(ret);\n        }\n      };\n    },\n\n    /**\n     * Apply a partial state object to the current state, invoking registered listeners.\n     * @param {Object} update\t\t\t\tAn object with properties to be merged into state\n     * @param {Boolean} [overwrite=false]\tIf `true`, update will replace state instead of being merged into it\n     */\n    setState,\n\n    /**\n     * Register a listener function to be called whenever state is changed. Returns an `unsubscribe()` function.\n     * @param {Function} listener\tA function to call when state changes. Gets passed the new state.\n     * @returns {Function} unsubscribe()\n     */\n    subscribe(listener: Listener<State>) {\n      listeners.push(listener);\n      return () => {\n        unsubscribe(listener);\n      };\n    }\n\n    // /**\n    //  * Remove a previously-registered listener function.\n    //  * @param {Function} listener\tThe callback previously passed to `subscribe()` that should be removed.\n    //  * @function\n    //  */\n    // unsubscribe,\n  };\n};\n","import { Store, createStore } from \"./store\";\nimport { Connection } from \"./connection\";\nimport { UnsubscribeFunc } from \"./types\";\n\nexport type Collection<State> = {\n  state: State;\n  refresh(): Promise<void>;\n  subscribe(subscriber: (state: State) => void): UnsubscribeFunc;\n};\n\nexport const getCollection = <State>(\n  conn: Connection,\n  key: string,\n  fetchCollection: (conn: Connection) => Promise<State>,\n  subscribeUpdates?: (\n    conn: Connection,\n    store: Store<State>\n  ) => Promise<UnsubscribeFunc>\n): Collection<State> => {\n  if (conn[key]) {\n    return conn[key];\n  }\n\n  let active = 0;\n  let unsubProm: Promise<UnsubscribeFunc>;\n  let store = createStore<State>();\n\n  const refresh = () =>\n    fetchCollection(conn).then(state => store.setState(state, true));\n\n  conn[key] = {\n    get state() {\n      return store.state;\n    },\n\n    refresh,\n\n    subscribe(subscriber: (state: State) => void): UnsubscribeFunc {\n      if (!active) {\n        active++;\n\n        // Subscribe to changes\n        if (subscribeUpdates) {\n          unsubProm = subscribeUpdates(conn, store);\n        }\n\n        // Fetch when connection re-established.\n        conn.addEventListener(\"ready\", refresh);\n\n        refresh().catch((err: unknown) => {\n          // Swallow errors if socket is connecting, closing or closed.\n          // We will automatically call refresh again when we re-establish the connection.\n          // Using conn.socket.OPEN instead of WebSocket for better node support\n          if (conn.socket.readyState == conn.socket.OPEN) {\n            throw err;\n          }\n        });\n      }\n\n      const unsub = store.subscribe(subscriber);\n\n      if (store.state !== undefined) {\n        subscriber(store.state);\n      }\n\n      return () => {\n        unsub();\n        active--;\n        if (!active) {\n          // Unsubscribe from changes\n          if (unsubProm)\n            unsubProm.then(unsub => {\n              unsub();\n            });\n          conn.removeEventListener(\"ready\", refresh);\n        }\n      };\n    }\n  };\n\n  return conn[key];\n};\n\n// Legacy name. It gets a collection and subscribes.\nexport const createCollection = <State>(\n  key: string,\n  fetchCollection: (conn: Connection) => Promise<State>,\n  subscribeUpdates:\n    | ((conn: Connection, store: Store<State>) => Promise<UnsubscribeFunc>)\n    | undefined,\n  conn: Connection,\n  onChange: (state: State) => void\n): UnsubscribeFunc =>\n  getCollection(conn, key, fetchCollection, subscribeUpdates).subscribe(\n    onChange\n  );\n","import { Connection } from \"./connection\";\nimport * as messages from \"./messages\";\nimport { HassEntity, HassServices, HassConfig, HassUser } from \"./types\";\n\nexport const getStates = (connection: Connection) =>\n  connection.sendMessagePromise<HassEntity[]>(messages.states());\n\nexport const getServices = (connection: Connection) =>\n  connection.sendMessagePromise<HassServices>(messages.services());\n\nexport const getConfig = (connection: Connection) =>\n  connection.sendMessagePromise<HassConfig>(messages.config());\n\nexport const getUser = (connection: Connection) =>\n  connection.sendMessagePromise<HassUser>(messages.user());\n\nexport const callService = (\n  connection: Connection,\n  domain: string,\n  service: string,\n  serviceData?: object\n) =>\n  connection.sendMessagePromise(\n    messages.callService(domain, service, serviceData)\n  );\n","import { getCollection } from \"./collection\";\nimport { HassConfig, UnsubscribeFunc } from \"./types\";\nimport { Connection } from \"./connection\";\nimport { Store } from \"./store\";\nimport { getConfig } from \"./commands\";\n\ntype ComponentLoadedEvent = {\n  data: {\n    component: string;\n  };\n};\n\nfunction processComponentLoaded(\n  state: HassConfig,\n  event: ComponentLoadedEvent\n): Partial<HassConfig> | null {\n  if (state === undefined) return null;\n\n  return {\n    components: state.components.concat(event.data.component)\n  };\n}\n\nconst fetchConfig = (conn: Connection) => getConfig(conn);\nconst subscribeUpdates = (conn: Connection, store: Store<HassConfig>) =>\n  conn.subscribeEvents(\n    store.action(processComponentLoaded),\n    \"component_loaded\"\n  );\n\nconst configColl = (conn: Connection) =>\n  getCollection(conn, \"_cnf\", fetchConfig, subscribeUpdates);\n\nexport const subscribeConfig = (\n  conn: Connection,\n  onChange: (state: HassConfig) => void\n): UnsubscribeFunc => configColl(conn).subscribe(onChange);\n","import { getCollection } from \"./collection\";\nimport { HassServices, HassDomainServices, UnsubscribeFunc } from \"./types\";\nimport { Connection } from \"./connection\";\nimport { Store } from \"./store\";\nimport { getServices } from \"./commands\";\n\ntype ServiceRegisteredEvent = {\n  data: {\n    domain: string;\n    service: string;\n  };\n};\n\ntype ServiceRemovedEvent = {\n  data: {\n    domain: string;\n    service: string;\n  };\n};\n\nfunction processServiceRegistered(\n  state: HassServices,\n  event: ServiceRegisteredEvent\n) {\n  if (state === undefined) return null;\n\n  const { domain, service } = event.data;\n\n  const domainInfo = Object.assign({}, state[domain], {\n    [service]: { description: \"\", fields: {} }\n  });\n\n  return { [domain]: domainInfo };\n}\n\nfunction processServiceRemoved(\n  state: HassServices,\n  event: ServiceRemovedEvent\n) {\n  if (state === undefined) return null;\n\n  const { domain, service } = event.data;\n  const curDomainInfo = state[domain];\n\n  if (!curDomainInfo || !(service in curDomainInfo)) return null;\n\n  const domainInfo: HassDomainServices = {};\n  Object.keys(curDomainInfo).forEach(sKey => {\n    if (sKey !== service) domainInfo[sKey] = curDomainInfo[sKey];\n  });\n\n  return { [domain]: domainInfo };\n}\n\nconst fetchServices = (conn: Connection) => getServices(conn);\nconst subscribeUpdates = (conn: Connection, store: Store<HassServices>) =>\n  Promise.all([\n    conn.subscribeEvents<ServiceRegisteredEvent>(\n      store.action(processServiceRegistered),\n      \"service_registered\"\n    ),\n    conn.subscribeEvents<ServiceRemovedEvent>(\n      store.action(processServiceRemoved),\n      \"service_removed\"\n    )\n  ]).then(unsubs => () => unsubs.forEach(fn => fn()));\n\nconst servicesColl = (conn: Connection) =>\n  getCollection(conn, \"_srv\", fetchServices, subscribeUpdates);\n\nexport const subscribeServices = (\n  conn: Connection,\n  onChange: (state: HassServices) => void\n): UnsubscribeFunc => servicesColl(conn).subscribe(onChange);\n","import { getCollection } from \"./collection\";\nimport { HassEntities, StateChangedEvent, UnsubscribeFunc } from \"./types\";\nimport { Connection } from \"./connection\";\nimport { Store } from \"./store\";\nimport { getStates } from \"./commands\";\n\nfunction processEvent(store: Store<HassEntities>, event: StateChangedEvent) {\n  const state = store.state;\n  if (state === undefined) return;\n\n  const { entity_id, new_state } = event.data;\n  if (new_state) {\n    store.setState({ [new_state.entity_id]: new_state });\n  } else {\n    const newEntities = Object.assign({}, state);\n    delete newEntities[entity_id];\n    store.setState(newEntities, true);\n  }\n}\n\nasync function fetchEntities(conn: Connection): Promise<HassEntities> {\n  const states = await getStates(conn);\n  const entities: HassEntities = {};\n  for (let i = 0; i < states.length; i++) {\n    const state = states[i];\n    entities[state.entity_id] = state;\n  }\n  return entities;\n}\n\nconst subscribeUpdates = (conn: Connection, store: Store<HassEntities>) =>\n  conn.subscribeEvents<StateChangedEvent>(\n    ev => processEvent(store, ev as StateChangedEvent),\n    \"state_changed\"\n  );\n\nexport const entitiesColl = (conn: Connection) =>\n  getCollection(conn, \"_ent\", fetchEntities, subscribeUpdates);\n\nexport const subscribeEntities = (\n  conn: Connection,\n  onChange: (state: HassEntities) => void\n): UnsubscribeFunc => entitiesColl(conn).subscribe(onChange);\n","import { ConnectionOptions } from \"./types\";\nimport { createSocket } from \"./socket\";\nimport { Connection } from \"./connection\";\n\nexport * from \"./auth\";\nexport * from \"./collection\";\nexport * from \"./connection\";\nexport * from \"./config\";\nexport * from \"./services\";\nexport * from \"./entities\";\nexport * from \"./errors\";\nexport * from \"./types\";\nexport * from \"./commands\";\n\nconst defaultConnectionOptions: ConnectionOptions = {\n  setupRetry: 0,\n  createSocket\n};\n\nexport async function createConnection(options?: Partial<ConnectionOptions>) {\n  const connOptions: ConnectionOptions = Object.assign(\n    {},\n    defaultConnectionOptions,\n    options\n  );\n  const socket = await connOptions.createSocket(connOptions);\n  const conn = new Connection(socket, connOptions);\n  return conn;\n}\n","/**\n * Create a web socket connection with a Home Assistant instance.\n */\nimport {\n  ERR_INVALID_AUTH,\n  ERR_CANNOT_CONNECT,\n  ERR_HASS_HOST_REQUIRED\n} from \"./errors\";\nimport { ConnectionOptions, Error } from \"./types\";\nimport * as messages from \"./messages\";\n\nconst DEBUG = false;\n\nconst MSG_TYPE_AUTH_REQUIRED = \"auth_required\";\nconst MSG_TYPE_AUTH_INVALID = \"auth_invalid\";\nconst MSG_TYPE_AUTH_OK = \"auth_ok\";\n\nexport function createSocket(options: ConnectionOptions): Promise<WebSocket> {\n  if (!options.auth) {\n    throw ERR_HASS_HOST_REQUIRED;\n  }\n  const auth = options.auth;\n  const wsConstructor = options.WebSocket || WebSocket;\n\n  // Start refreshing expired tokens even before the WS connection is open.\n  // We know that we will need auth anyway.\n  let authRefreshTask = auth.expired\n    ? auth.refreshAccessToken().then(\n        () => {\n          authRefreshTask = undefined;\n        },\n        () => {\n          authRefreshTask = undefined;\n        }\n      )\n    : undefined;\n\n  // Convert from http:// -> ws://, https:// -> wss://\n  const url = auth.wsUrl;\n\n  if (DEBUG) {\n    console.log(\"[Auth phase] Initializing\", url);\n  }\n\n  function connect(\n    triesLeft: number,\n    promResolve: (socket: WebSocket) => void,\n    promReject: (err: Error) => void\n  ) {\n    if (DEBUG) {\n      console.log(\"[Auth Phase] New connection\", url);\n    }\n\n    // @ts-ignore\n    const socket = new wsConstructor(url);\n\n    // If invalid auth, we will not try to reconnect.\n    let invalidAuth = false;\n\n    const closeMessage = () => {\n      // If we are in error handler make sure close handler doesn't also fire.\n      socket.removeEventListener(\"close\", closeMessage);\n      if (invalidAuth) {\n        promReject(ERR_INVALID_AUTH);\n        return;\n      }\n\n      // Reject if we no longer have to retry\n      if (triesLeft === 0) {\n        // We never were connected and will not retry\n        promReject(ERR_CANNOT_CONNECT);\n        return;\n      }\n\n      const newTries = triesLeft === -1 ? -1 : triesLeft - 1;\n      // Try again in a second\n      setTimeout(\n        () =>\n          connect(\n            newTries,\n            promResolve,\n            promReject\n          ),\n        1000\n      );\n    };\n\n    // Auth is mandatory, so we can send the auth message right away.\n    const handleOpen = async (event: MessageEventInit) => {\n      try {\n        if (auth.expired) {\n          await (authRefreshTask ? authRefreshTask : auth.refreshAccessToken());\n        }\n        socket.send(JSON.stringify(messages.auth(auth.accessToken)));\n      } catch (err) {\n        // Refresh token failed\n        invalidAuth = err === ERR_INVALID_AUTH;\n        socket.close();\n      }\n    };\n\n    const handleMessage = async (event: MessageEvent) => {\n      const message = JSON.parse(event.data);\n\n      if (DEBUG) {\n        console.log(\"[Auth phase] Received\", message);\n      }\n      switch (message.type) {\n        case MSG_TYPE_AUTH_INVALID:\n          invalidAuth = true;\n          socket.close();\n          break;\n\n        case MSG_TYPE_AUTH_OK:\n          socket.removeEventListener(\"open\", handleOpen);\n          socket.removeEventListener(\"message\", handleMessage);\n          socket.removeEventListener(\"close\", closeMessage);\n          socket.removeEventListener(\"error\", closeMessage);\n          promResolve(socket);\n          break;\n\n        default:\n          if (DEBUG) {\n            // We already send this message when socket opens\n            if (message.type !== MSG_TYPE_AUTH_REQUIRED) {\n              console.warn(\"[Auth phase] Unhandled message\", message);\n            }\n          }\n      }\n    };\n\n    socket.addEventListener(\"open\", handleOpen);\n    socket.addEventListener(\"message\", handleMessage);\n    socket.addEventListener(\"close\", closeMessage);\n    socket.addEventListener(\"error\", closeMessage);\n  }\n\n  return new Promise((resolve, reject) =>\n    connect(\n      options.setupRetry,\n      resolve,\n      reject\n    )\n  );\n}\n"],"names":["_Pact","prototype","then","onFulfilled","onRejected","result","state","this","s","callback","_settle","v","e","o","_this","value","pact","bind","observer","_catch","body","recover","_earlyReturn","_AsyncGenerator","entry","_entry","_pact","_resolve","_return","_promise","_wrapReturnedValue","done","_wrapYieldedValue","Symbol","asyncIterator","_yield","next","Promise","resolve","returnValue","error","return","throw","reject","ERR_CANNOT_CONNECT","ERR_INVALID_AUTH","ERR_CONNECTION_LOST","ERR_HASS_HOST_REQUIRED","Connection","constructor","socket","options","commandId","commands","eventListeners","closeRequested","setSocket","oldSocket","addEventListener","ev","_handleMessage","_handleClose","oldCommands","keys","forEach","id","info","subscribe","unsub","unsubscribe","fireEvent","eventType","listeners","push","removeEventListener","index","indexOf","splice","eventData","close","subscribeEvents","subscribeMessage","message","type","event_type","messages","ping","sendMessagePromise","sendMessage","_genCmdId","send","JSON","stringify","_this2","subscription","err","event","parse","data","success","Object","assign","reconnect","tries","createSocket","Math","min","getAuth","Auth","saveTokens","hassUrl","undefined","length","substr","clientId","genClientId","redirectUrl","includes","document","location","href","authorizeUrl","encodeURIComponent","genAuthorizeUrl","redirectAuthorize","btoa","loadTokens","query","queryString","items","search","split","i","item","key","decodeURIComponent","parseQuery","atob","code","tokenRequest","grant_type","console","log","formData","FormData","append","fetch","method","credentials","resp","ok","status","Error","json","tokens","expires","genExpires","expires_in","Date","now","_saveTokens","prototypeAccessors","wsUrl","accessToken","access_token","expired","refreshAccessToken","refresh_token","revoke","const","getCollection","conn","fetchCollection","subscribeUpdates","unsubProm","active","store","setState","update","overwrite","currentListeners","action","apply","args","arguments","ret","listener","out","createStore","refresh","subscriber","catch","readyState","OPEN","createCollection","onChange","getStates","connection","getServices","getConfig","getUser","callService","domain","service","serviceData","service_data","processComponentLoaded","components","concat","component","fetchConfig","subscribeConfig","configColl","processServiceRegistered","domainInfo","description","fields","processServiceRemoved","curDomainInfo","sKey","fetchServices","all","unsubs","fn","subscribeServices","servicesColl","fetchEntities","states","entities","entity_id","new_state","newEntities","processEvent","entitiesColl","subscribeEntities","createConnection","connOptions","defaultConnectionOptions","setupRetry","auth","wsConstructor","WebSocket","authRefreshTask","url","connect","triesLeft","promResolve","promReject","invalidAuth","closeMessage","newTries","setTimeout","handleOpen","handleMessage"],"mappings":"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"}